// 引用与所有权真是麻烦，很难理解rust里面的语义！！！！！
// copy特征的类型,
//
// 总结
// 1、借用不改变内存的所有者（Owner），借用只是对源内存的临时引用。
// 2、在借用周期内，借用方可以读写这块内存，所有者被禁止读写内存；且所有者保证在有“借用”存在的情况下，不会释放或转移内存。
// 3、失去所有权的变量不可以被借用（访问）。
// 4、在租借期内，内存所有者保证不会释放/转移/可变租借这块内存，但如果是在非可变租借的情况下，所有者是允许继续非可变租借出去的。
// 5、借用周期满后，所有者收回读写权限
// 6、借用周期小于被借用者（所有者）的生命周期。


fn main() {
    let mut x = 5; //默认不可变
    let y = &mut x; //已经有一个可变借用了。
    *y += 1;
    println!("address y:{}", y);
    println!("address y:{}", y);
    println!("-----------------");
    let mut k = 123;
    {
        let k_bak = &mut k; //借用可变变量,rust让我们更加关注等号的右边的表达式。
        //这个和C / C ++一样，&取出变量的地址，通过* 解引用获取原始值进行操作。
        //而比较误导的就是为什么不是let * k_bak = &mut k呢？这个是和let自动推到类型的原因。
        //借出去后，原来的拥有者，在使用时，只能等到借用者释放资源。
        *k_bak += 1; //
    }
    {
        //上面以及这个括号，去掉都会报错，原因，在于资源借用出去了，就只能等到借用者释放它，
        //否则，是无法使用的，这就要求我们借用者的作用域小于原来的拥有者。即存在借用方时，原有者禁止使用
        //这也就是，有借就要还的道理。
        let k_bak = &mut k;
        *k_bak += 1002;
    }
    fun(&mut k); //
    *(&mut k) += 1; //这样也可以使用，思考一下就知道了。
    println!("*&mut k += 1 => {}", k);
    *(&mut (*(&mut k))) += 1; //这样也可以使用，思考一下就知道了。
    println!("*(&mut (*(&mut k))) += 1 => {}", k);
    *&mut *&mut k += 1;
    println!("*&mut*&mut k += 1 => {}", k); //这样就要好好思考了。
    k += 1;
    println!("k  : {}", &k);
    println!("k  : {}", k);
    // println!("y  : {}", k);
    // println!("y  : {}", &k);
    // println!("y  : {}", &mut k);
    //  let mut k_bak =  &k;
    // println!("address x:{}", &mut x);
    // fun(&y); //&y

    let ii: i32;
    ii = 2;
    // ii = 121;
    println!("----ii :{}", ii);

    let mut var = 132;
    println!("---var :{}", var);
    var += 3113;
    let var_ref = &mut var;

    println!("---var :{}", var);

}

fn fun(i: &mut i32) {
    *i += 1;
    println!("values:{}", i);
}
